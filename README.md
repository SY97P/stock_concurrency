# 재고 시스템으로 알아보는 동시성 이슈 해결방법

## 동시성 이슈

> 재고량을 감소시키는 메소드를 여러 스레드(요청)에서 동시에 접근하게 된다면?
- 재고량 감소 = select + decrease + update
- 한 스레드가 select 하고 update 하기 전, 다른 스레드에서 select 를 하게 되어 동시성 문제 발생

## Synchronized
- 메소드에 `synchronized` 키워드
- 한 스레드의 요청이 끝날 때까지 다른 스레드를 대기시킴
### @Transactional 어노테이션과 함께 쓰지 못함
- 다만, 메소드나 클래스에 Spring `@Transactional` 어노테이션이 선언되었다면, 또다시 동시성 문제 발생
- @Transactional 어노테이션이 프록시로 동작하기 때문
  - 해당 메소드를 프록시로 만들어 호출하기 때문에 동시성 문제가 해결되지 않음
  - 요청 별로 별도의 프록시를 만들어 호출하기 때문으로 보임
### 하나의 프로세스 안에서만 동시성 보장
- 만약 서버가 여러 대라면, 서버 별로 프로세스가 생성되므로 동시성 문제를 해결할 수 없음
- 요즘에는 대부분 여러 서버로 구성하기 때문에 synchonized 키워드는 잘 사용하지 않는 방식

## MySQL 활용한 다양한 방법
### 1. Pessimistic Lock (비관적 락)
- 실제로 데이터에 `락`을 걸어서 정합성 맞추는 방법
- 배타락 걸면, 다른 트랜잭션에선 해당 데이터에 락 해제 전까지 접근 불가
- `데드락` 가능성 있으므로 주의
### 2. Optimistic Lock (낙관적 락)
- 실제 락을 이용하지 않고, `버전`을 이용하여 정합성 맞추는 방법
- 데이터 select 후 update 할 때, 버전 일치 여부를 확인해 update
- 만약 update 하려는 버전에 수정사항이 있는 경우(select 시점과 버전 불일치) 재시도 해야 함.
### 3. Named Lock
- 이름 가진 metadata locking
- Named Lock 획득 후 해제될 때까지 다른 세션은 해당 락 획득 불가
- `Transaction 종료 시 락 자동 해제가 되지 않으므로 주의!`
  - 별도 명령으로 락 해제
  - 선점 시간 종료로 락 해제